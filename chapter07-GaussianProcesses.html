
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>第 7 章 高斯过程 &#8212; 用Python做贝叶斯分析</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="第6章 混合模型" href="chapter06-MixtureModels.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">用Python做贝叶斯分析</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="preface.html">
   封面
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter01-ThinkingProbabilistically.html">
   第1章 概率思维
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter02-ProgrammingProbabilistically.html">
   第 2 章 概率编程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter03-ModellingwithLinearRegression.html">
   第 3 章 线性回归模型的贝叶斯视角
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter04-GeneralizedLinearRegression.html">
   第 4 章 广义线性回归模型与分类任务
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter05-ModelComparison.html">
   第 5 章 模型比较
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter06-MixtureModels.html">
   第6章 混合模型
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   第 7 章 高斯过程
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/chapter07-GaussianProcesses.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id2">
   7.1 线性模型和非线性数据
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id3">
   7.2 对函数建模
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id4">
     7.2.1 多元高斯与函数
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id5">
     7.2.2 协方差函数与核
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id6">
     7.2.3 高斯过程
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id7">
   7.3 高斯过程回归
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id8">
   7.4 空间自相关回归
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id9">
   7.5 高斯过程分类
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cox">
   7.6 Cox 过程
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id10">
     7.6.1 煤矿灾害
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id11">
     7.6.2 红杉数据集
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id12">
   7.7 总结
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id13">
   7.8 练习
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="id1">
<h1>第 7 章 高斯过程<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<style>p{text-indent:2em;2}</style>
<p>在上一章中，我们学习了狄利克雷过程，它是狄利克雷分布的无限维推广，可用于设置未知连续分布的先验。在本章中，我们将学习高斯过程，这是高斯分布的无限维推广，可用于设置未知函数的先验。在贝叶斯统计中，狄利克雷过程和高斯过程都被用来建立灵活的模型，其中允许参数的数量随着数据的大小而增加。</p>
<p>本章我们将学习：</p>
<ul class="simple">
<li><p>函数作为概率对象</p></li>
<li><p>核</p></li>
<li><p>具有高斯似然的高斯过程</p></li>
<li><p>具有非高斯似然的高斯过程</p></li>
</ul>
<hr class="docutils" />
<div class="section" id="id2">
<h2>7.1 线性模型和非线性数据<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>7.1 非参统计</p>
<p>非参统计通常用来描述一类不依赖于参数化概率分布的统计工具/模型。根据这个定义，贝叶斯统计似乎不可能是非参的，因为前面我们学到过，贝叶斯统计的第一步就是在概率模型中准确地将概率 分布组合在一起。第 1 章中说过，概率分布是构建概率模型的基石。 在贝叶斯框架中，非参模型是指包含有无限多参数的模型，因此，我 们将参数可以随着数据大小而变化的模型称作非参数化模型。对于非 参数化模型而言，理论上其参数个数是无限的，实际使用中会根据数 据将其收缩到一个有限的值，从而让数据本身来决定参数的个数。</p>
</div>
<div class="section" id="id3">
<h2>7.2 对函数建模<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>我们将首先描述一种将函数表示为概率对象的方法，以开始对高斯过程的讨论。可以把函数 $f$ 看作是从一组输入 $x$ 到一组输出 $y$ 的映射。因此，可以这样写：</p>
<p>$$ y=f(x) $$</p>
<p>表示函数的一种方式是为每个值 $x_i$ 列出其相应值 $y_i$ 。事实上，你可能还记得小学时函数的这种表示方式：</p>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505201816_b3.webp" /></p>
<p>一般情况下，$x$ 和 $y$ 的值将位于实数行上；因此，可将函数视为成对$( x_i,y_i)$ 值的（可能）无限有序列表。顺序很重要，因为如果打乱这些值，会得到不同的函数。</p>
<p>函数也可以表示为一个由 $x$ 的值索引的（潜在）无限数组，但重要区别在于，$x$ 的值不限于整数，可以取实数。</p>
<p>使用这些描述，我们可以用数字表示任何想要的特定函数。但如果想要以概率表示函数呢？可以通过让映射具有概率性质来做到这一点。让我来解释一下：可以让每个 $y_i$ 值都是一个高斯分布的随机变量，具有给定的均值和方差。通过这种方式，我们不再有对单个特定功能的描述，而是对一系列分布族的描述。</p>
<p>为了使讨论具体化，让我们使用一些 Python 代码来构建和绘制这类函数的两个示例：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;the first one&#39;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;the second one&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505202243_46.webp" /></p>
<p>图 7.1 显示，使用高斯分布的样本对函数进行编码并不是那么疯狂或愚蠢，因此我们可能是在正确的轨道上。然而，用于生成图 7.1 的方法是有限的，并且不够灵活。虽然我们期望实函数具有某种结构或模式，但我们表达第一个函数的方式并不允许我们编码数据点之间的任何关系。事实上，每个点都是完全独立的，因为我们只从一个常见的一维高斯分布中获得了 10 个独立的样本。对于第二个函数，我们引入了一些依赖项。该点的平均值就是值。然而，接下来我们将看到有一种更通用的方法来捕获依赖项（并且不仅仅是在连续点之间）。</p>
<p>在继续之前，让我停一会儿问你们，为什么我们使用的是高斯分布，而不是任何其他的概率分布？首先，因为通过限制我们与高斯人合作，我们不会失去任何指定不同形状函数的灵活性，因为每个点都可能有其自己的均值和方差；其次，因为从数学的角度来看，与高斯人合作是很好的。</p>
<div class="section" id="id4">
<h3>7.2.1 多元高斯与函数<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>在图 7.1 中，我们使用高斯表示一个函数来获取样本。一种替代方法是使用多变量高斯分布来获得长度的样本向量。实际上，您可能希望尝试通过使用 np.random.multivariate_normal(np.zeros_like(x), np.eye(len(x))) 替换 np.random.normal(0, 1, len(x)) 来生成如图 7.1 所示的图形。</p>
<p>您将看到第一条语句等同于第二条语句，但是现在我们可以使用协方差矩阵来编码有关数据点如何相互关联的信息。通过允许协方差矩阵为 np.ye(len(X))，我们基本上表示这 10 个点中的每个点的方差为 1，并且它们之间的方差（即，它们的协方差）为 0（因此，它们是独立的）。如果我们用其他（正）数字替换这些零，我们可能得到的协方差告诉我们一个不同的故事。因此，要以概率方式表示函数，我们只需要一个具有合适协方差矩阵的多变量高斯函数，我们将在下一节中看到。</p>
</div>
<div class="section" id="id5">
<h3>7.2.2 协方差函数与核<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>实际上，协方差矩阵是使用称为核的函数指定的。您可能会在统计文献中找到多个核的定义，它们的数学属性略有不同。出于我们讨论的目的，我们将说内核基本上是一个对称函数，它接受两个输入，并在输入中返回零值，否则相同或为正。如果满足这些条件，我们可以将核函数的输出解释为两个输入之间的相似性度量。</p>
<p>在众多可用的有用内核中，常用的一种是指数二次核：
$$
K\left(x, x^{\prime}\right)=\exp \left(-\frac{\left|x-x^{\prime}\right|^{2}}{2 \ell^{2}}\right)
$$
此处， $ \left|x-x^{\prime}\right|^{2} $ 为平方欧氏距离：
$$
\left|x-x^{\prime}\right|^{2}=\left(x_{1}-x_{1}^{\prime}\right)^{2}+\left(x_{2}-x_{2}^{\prime}\right)^{2}+\cdots+\left(x_{n}-x_{n}^{\prime}\right)^{2}
$$
乍一看可能不明显，但幂二次核具有与高斯分布类似的公式（见表达式 1.3)。因此，您可能会发现有人将此内核称为高斯内核。该术语称为长度标度（或带宽或方差），用于控制内核的宽度。</p>
<p>为了更好地理解内核的作用，让我们定义一个 Python 函数来计算指数二次内核：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">exp_quad_kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">knots</span><span class="p">,</span> <span class="n">ℓ</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;exponentiated quadratic kernel&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">ℓ</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">knots</span><span class="p">])</span>
</pre></div>
</div>
<p>以下代码和图 7.2 旨在显示协方差矩阵如何查找不同的输入。我选择的输入相当简单，由值 [-1，0，1，2] 组成。理解此示例后，您应该尝试使用其他输入（请参见练习 1)：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">cov</span> <span class="o">=</span> <span class="n">exp_quad_kernel</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="o">+</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1">#ax[0].set_xticklabels(np.round(data, 2), rotation=70)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">im</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)):</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span>
                   <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)],</span>
                   <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">})</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505203138_6f.webp" /></p>
<p>图 7.2 左侧的面板显示输入，x 轴上的值表示每个数据点的值，文本注释显示数据点的顺序（从零开始）。在右边的面板上，我们有一个热图，表示使用指数二次核获得的协方差矩阵。颜色越浅，协方差越大。如您所见，热图是对称的，对角线取较大的值。协方差矩阵中每个元素的值与点之间的距离成反比，因为对角线是每个数据点与其自身进行比较的结果。对于这个核，我们得到最接近的距离 0 和更高的协方差值 1。其他值对于其他内核也是可能的。</p>
<p>内核将数据点沿 x 轴的距离转换为预期函数值（在 y 轴上）的协方差值。因此，x 轴上的两个点越近，我们预计它们在 y 轴上的值就越相似。</p>
<p>总而言之，到目前为止，我们已经看到，我们可以使用具有给定协方差的多元正态分布来建模函数。我们可以使用核函数来建立协方差。在下面的示例中，我们使用 exp_quad_kernel 函数来定义多变量正态分布的协方差矩阵，然后使用该分布中的样本来表示函数：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="n">test_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">constrained_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ℓ</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">exp_quad_kernel</span><span class="p">(</span><span class="n">test_points</span><span class="p">,</span> <span class="n">test_points</span><span class="p">,</span> <span class="n">ℓ</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">test_points</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">cov</span><span class="o">=</span><span class="n">cov</span><span class="p">,</span>
<span class="n">size</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ℓ =</span><span class="si">{</span><span class="n">ℓ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.51</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.03</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="o">-</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;f(x)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505203247_f6.webp" /></p>
<p>如图 7.3 所示，高斯核包含多种函数，其参数控制函数的平滑度。的值越大，函数越平滑。</p>
</div>
<div class="section" id="id6">
<h3>7.2.3 高斯过程<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>现在我们已经准备好了解什么是高斯过程 (GP) 以及它们是如何在实践中使用的。</p>
<p>从维基百科 (Wikipedia) 上摘取的对高斯过程的一个比较正式的定义如下：</p>
<p>按时间或空间索引的随机变量的集合，使得这些随机变量的每个有限集合都具有多元正态分布，即它们的每个有限线性组合都是正态分布的。</p>
<p>理解高斯过程的诀窍是认识到 GP 的概念是一个心理（和数学）脚手架，因为在实践中，我们不需要直接处理这个无限的数学对象。相反，我们只在我们有数据的地方评估高斯过程。通过这样做，我们将无限维 GP 压缩成一个有限的多元高斯分布，其维数和数据点一样多。从数学上讲，这种崩溃是由无限不可观测的维度上的边际化造成的。理论向我们保证，省略（实际上边缘化）所有的点是可以的，除了我们正在观察的那些点。它还保证我们将始终得到多变量的高斯分布。因此，我们可以严格地将图 7.3 解释为来自高斯过程的实际样本！</p>
<p>请注意，我们将多变量高斯函数的平均值设置为零，并通过指数二次核仅使用协方差矩阵对函数进行建模。在使用高斯过程时，将多变量高斯的平均值设置为零是常见的做法。</p>
<p>高斯过程对于构建贝叶斯非参数模型很有用，因为我们可以将它们用作函数上的先验分布。</p>
</div>
</div>
<div class="section" id="id7">
<h2>7.3 高斯过程回归<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>让我们假设我们可以将一个值建模为加一些噪声的函数：</p>
<p>$$
y \sim \mathcal{N}(\mu=f(x), \sigma=\epsilon)
$$
此处 $ \epsilon \sim \mathcal{N}\left(0, \sigma_{\epsilon}\right) $</p>
<p>这类似于我们在第 3 章“线性回归建模”中对线性回归模型所做的假设。主要区别在于，现在我们将优先分配。高斯过程可以作为这样的先验，因此我们可以这样写：</p>
<p>$$
f(x) \sim \mathcal{G} \mathcal{P}\left(\mu_{x}, K\left(x, x^{\prime}\right)\right)
$$</p>
<p>这里，$\mathcal{GP}$ 表示高斯过程分布， $\mu_x$ 为均值函数， $K(x,x’)$ 为核函数或协方差函数。在这里，我们用函数这个词来表示，在数学上，均值和协方差是无限的对象，即使在实践中，我们总是处理有限的对象。</p>
<p>如果先验分布是 GP，并且似然是正态分布，那么后验分布也是 GP，我们可以解析地计算它：
$$
\begin{array}{c}
p\left(f\left(X_{<em>}\right) \mid X_{</em>}, X, y\right) \sim \mathcal{N}(\mu, \Sigma) \
\mu=K_{<em>}^{T} K^{-1} y \
\Sigma=K_{</em> <em>}-K_{</em>}^{T} K^{-1} K_{<em>}
\end{array}
$$
这里：
$$
\begin{array}{l}
\text { - } K=K(X, X) \
\text { - } K_{</em>}=K\left(X_{<em>}, X\right) \
\text { - } K_{</em> <em>}=K\left(X_{</em>}, X_{*}\right)
\end{array}
$$</p>
<p>$X$ 是观察到的数据点，$X_*$ 表示测试点；也就是我们希望知道推断函数值的新点。</p>
<p>像往常一样，PyMC3 允许我们通过为我们处理几乎所有的数学细节来执行推理，高斯过程也不例外。因此，让我们继续创建一些数据，然后创建一个 PyMC3 模型：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">true_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">true_x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">true_x</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204212_c1.webp" /></p>
<p>在图 7.4 中，我们看到真正的未知函数是一条黑虚线，而点表示未知函数的样本（带有噪声）。</p>
<p>请注意，为了将公式 7.7 和 7.8 编码到 PyMC3 模型中，我们只需要找出指数二次核的参数、正态似然方差和长度-尺度参数。</p>
<p>GPS 在 PyMC3 中实现为一系列 Python 类，与我们在以前的模型中看到的略有不同；然而，代码仍然非常 PyMC3onic。我在以下代码中添加了一些注释，以指导您完成使用 PyMC3 定义 GP 的关键步骤：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># A one dimensional column vector of inputs.</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_reg</span><span class="p">:</span>
    <span class="c1"># hyperprior for lengthscale kernel parameter</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># instantiate a covariance function</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ℓ</span><span class="p">)</span>
    <span class="c1"># instantiate a GP prior</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Marginal</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="c1"># prior</span>
    <span class="n">ϵ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s1">&#39;ϵ&#39;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="c1"># likelihood</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">marginal_likelihood</span><span class="p">(</span><span class="s1">&#39;y_pred&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="n">ϵ</span><span class="p">)</span>
</pre></div>
</div>
<p>请注意，我们使用的不是表达式 7.7 中预期的正态似然，而是 gp.edge_lisilience 方法。你可能还记得，在第一章“概率思维”（公式 1.1) 和第五章“模型比较”（公式 5.13) 中，边际似然是似然和先验的积分：
$$
p(y \mid X, \theta) \sim \int p(y \mid f, X, \theta) p(f \mid X, \theta) d f
$$
与往常一样，表示所有未知参数，是自变量，也是因变量。请注意，我们正在对函数的值进行边际化。对于 GP 先验和正常可能性，可以解析地执行边际化。</p>
<p>根据 PyMC3 的核心开发者、GP 模块的主要贡献者 Bill Engels 的说法，对于长度尺度参数，优先避免零通常效果更好。在此之前，一个有用的默认设置是 pm.Gamma(2，0.5)。你可以从 Stan team 阅读更多关于默认有用历史的建议：https://github.com/stan-dev/stan/wiki/Prior-ChoiceRecommendations：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">az</span><span class="o">.</span><span class="n">plot_trace</span><span class="p">(</span><span class="n">trace_reg</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204431_42.webp" /></p>
<p>现在我们已经找到和的值，我们可能想要从 GP 后验中获取样本；即，拟合数据的函数的样本。我们可以通过使用 gp. 条件函数计算对新输入位置求值的条件分布来实现这一点：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="mi">100</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
<span class="k">with</span> <span class="n">model_reg</span><span class="p">:</span>
    <span class="n">f_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="s1">&#39;f_pred&#39;</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
</pre></div>
</div>
<p>结果，我们得到了一个新的 PyMC3 随机变量 f_pred，我们可以使用它从后验预测分布中获取样本（以 X_NEW 值计算）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">model_reg</span><span class="p">:</span>
    <span class="n">pred_samples</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample_posterior_predictive</span><span class="p">(</span><span class="n">trace_reg</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">f_pred</span><span class="p">],</span><span class="n">samples</span><span class="o">=</span><span class="mi">82</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们可以在原始数据上绘制拟合函数图，以直观地检查它们与数据的拟合程度以及预测中的相关不确定性：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">pred_samples</span><span class="p">[</span><span class="s1">&#39;f_pred&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;C1-&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
</pre></div>
</div>
<img src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204540_3f.webp" style="zoom:67%;" />
<p>或者，我们可以使用 pm.gp.util.lot_gp_dist 函数来获得一些不错的绘图。每个绘图代表一个百分位数，范围从 51（浅色）到 99（深色）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">plot_gp_dist</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pred_samples</span><span class="p">[</span><span class="s1">&#39;f_pred&#39;</span><span class="p">],</span> <span class="n">X_new</span><span class="p">,</span>
<span class="n">palette</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">plot_samples</span><span class="o">=</span><span class="kc">False</span><span class="p">);</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;f(x)&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204617_c7.webp" /></p>
<p>另一种选择是计算在参数空间中给定点评估的条件分布的平均向量和标准差。在下面的示例中，我们对 AND 使用平均值（跟踪中的样本）。我们可以使用 gp.recast 函数计算平均值和方差。我们之所以能做到这一点，是因为 PyMC3 已经解析地计算了后验结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">point</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ℓ&#39;</span><span class="p">:</span> <span class="n">trace_reg</span><span class="p">[</span><span class="s1">&#39;ℓ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="s1">&#39;ϵ&#39;</span><span class="p">:</span> <span class="n">trace_reg</span><span class="p">[</span><span class="s1">&#39;ϵ&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()}</span>
<span class="n">mu</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="n">point</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">var</span><span class="o">**</span><span class="mf">0.5</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="s1">&#39;C1&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_new</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                 <span class="n">mu</span> <span class="o">-</span> <span class="n">sd</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sd</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">X_new</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                 <span class="n">mu</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">sd</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">sd</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="s2">&quot;C1&quot;</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;ko&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204701_d1.webp" /></p>
<p>正如我们在第四章“推广线性模型”中所看到的，我们可以使用具有非高斯似然的线性模型和适当的逆链接函数来扩展线性模型的范围。我们可以为全科医生做同样的事情。例如，我们可以使用具有指数逆链接函数的泊松似然。对于这样的模型，后验不再是可分析处理的，但是，尽管如此，我们可以用数值方法来逼近它。在接下来的几节中，我们将讨论这种类型的模型。</p>
</div>
<div class="section" id="id8">
<h2>7.4 空间自相关回归<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>下面的例子取自理查德·麦克雷思 (Richard McElreath) 的“统计反思”(Statistics Reink) 一书。作者好心地允许我在这里重复使用他的例子。我强烈推荐你读他的书，因为你会发现很多像这样的好例子和非常好的解释。唯一需要注意的是，书中的示例是 R/stan 格式的，但请不要担心，请继续采样；您可以在 https://github.com/pymc-devs/Resources 中找到这些示例的 Python/PyMC3 版本。</p>
<p>好的，回到这个例子，我们有 10 个不同的岛屿社会；对于每一个，我们都有他们使用的工具的数量。一些理论预测，较大的人口会比较小的人口开发和维持更多的工具。另一个重要因素是人群间的接触率。</p>
<p>由于我们有许多工具作为因变量，我们可以使用泊松回归与总体作为自变量。事实上，我们可以使用人口的对数，因为（根据理论）真正重要的是人口的数量，而不是绝对的大小。将接触率包括在我们的模型中的一种方法是收集有关这些社会在历史上接触的频率的信息，并创建一个分类变量，如低/高接触率（请参阅岛屿数据帧中的 Contact 列）。另一种方式是使用社会之间的距离作为接触率的代理，因为可以合理地假设距离最近的社会比距离较远的社会更频繁地接触。</p>
<p>我们可以通过阅读本书附带的 ians_Dist.csv 文件来访问以千公里为单位表示的值的距离矩阵：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">islands_dist</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/islands_dist.csv&#39;</span><span class="p">,</span>
                           <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">islands_dist</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204845_7c.webp" /></p>
<p>如你所见，主对角线上填满了零。每个岛国社会都处于零公里的状态。矩阵也是对称的；上三角形和下三角形都有相同的信息。这是从 A 点到 B 点的距离与 B 点到 A 点的距离相同的直接结果。</p>
<p>工具数量和人口规模存储在另一个文件 islands.csv 中，该文件也随书一起分发：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">islands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/islands.csv&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
<span class="n">islands</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505204920_fd.webp" /></p>
<p>在此 DataFrame 中，我们将只使用列 culture, total_tools, lat, lon2,and logpop:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">islands_dist_sqr</span> <span class="o">=</span> <span class="n">islands_dist</span><span class="o">.</span><span class="n">values</span><span class="o">**</span><span class="mi">2</span>
<span class="n">culture_labels</span> <span class="o">=</span> <span class="n">islands</span><span class="o">.</span><span class="n">culture</span><span class="o">.</span><span class="n">values</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">islands</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
<span class="n">log_pop</span> <span class="o">=</span> <span class="n">islands</span><span class="o">.</span><span class="n">logpop</span>
<span class="n">total_tools</span> <span class="o">=</span> <span class="n">islands</span><span class="o">.</span><span class="n">total_tools</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">islands</span><span class="o">.</span><span class="n">lat</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">islands</span><span class="o">.</span><span class="n">lon</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]]</span>
</pre></div>
</div>
<p>我们要构建的模型是：</p>
<p>$$
f \sim \mathcal{G P}\left([0, \cdots, 0], K\left(x, x^{\prime}\right)\right) \
\mu \sim \exp (\alpha+\beta x+f) \
y \sim \operatorname{Poisson}(\mu)
$$
这里，我们省略了和的前缀，以及内核的超级前缀。是日志填充，是工具总数。</p>
<p>与第四章“推广线性模型”中的模型相比，该模型基本上是一个泊松回归模型，与第四章中的模型相比，线性模型中的一项来自 GP。为了计算 GP 的内核，我们将使用距离矩阵 ILANES_DIST。通过这种方式，我们将有效地纳入技术暴露的相似性度量（从距离矩阵估计）。因此，我们将把每个社会的工具数量建模为它们的地理相似性的函数，而不是假设总数量仅仅是人口的结果，并且从一个社会到另一个社会是独立的。</p>
<p>此模型（包括之前的模型）类似于 PyMC3 中的以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_islands</span><span class="p">:</span>
    <span class="n">η</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s1">&#39;η&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">η</span> <span class="o">*</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ℓ</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Latent</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">islands_dist_sqr</span><span class="p">)</span>
    <span class="n">α</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s1">&#39;α&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">β</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s1">&#39;β&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">α</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">β</span> <span class="o">*</span> <span class="n">log_pop</span><span class="p">)</span>
    <span class="n">tt_pred</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="s1">&#39;tt_pred&#39;</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">observed</span><span class="o">=</span><span class="n">total_tools</span><span class="p">)</span>
    <span class="n">trace_islands</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tune</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>为了了解协方差函数关于距离的后验分布，我们可以根据后验分布绘制一些样本：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trace_η</span> <span class="o">=</span> <span class="n">trace_islands</span><span class="p">[</span><span class="s1">&#39;η&#39;</span><span class="p">]</span>
<span class="n">trace_ℓ</span> <span class="o">=</span> <span class="n">trace_islands</span><span class="p">[</span><span class="s1">&#39;ℓ&#39;</span><span class="p">]</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">xrange</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">islands_dist</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">trace_η</span><span class="p">)</span> <span class="o">*</span>
        <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">trace_ℓ</span><span class="p">)</span> <span class="o">*</span> <span class="n">xrange</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xrange</span><span class="p">,</span> <span class="p">(</span><span class="n">trace_η</span><span class="p">[::</span><span class="mi">20</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="n">trace_ℓ</span><span class="p">[::</span><span class="mi">20</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span>
<span class="n">xrange</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
        <span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;distance (thousand kilometers)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;covariance&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205145_a6.webp" /></p>
<p>图 7.9 中的粗线是成对社会之间协方差作为距离函数的后验中位数。我们使用中位数是因为和的分布非常不对称。我们可以看到，协方差平均没有那么高，在大约 2000 公里处也降到了几乎为 0。细线代表不确定性，我们可以看到有很大的不确定性</p>
<p>您可能会发现，将 MODEL_IILAS 及其计算出的后部与 https://github.com/pymc-devs/ 参考资料中的模型 m_10_10 进行比较会很有趣。您可能希望使用 ArviZ 函数，例如 az.Summary 或 az.lot_Forest。模型 M1010 类似于 MODEL_ILANES，但不包含高斯过程项。</p>
<p>根据我们的模型，我们现在要探索这些岛屿之间的社会联系有多强。为此，我们必须将协方差矩阵转换为相关矩阵：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># compute posterior median covariance among societies</span>
<span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">trace_η</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">trace_ℓ</span><span class="p">)</span> <span class="o">*</span> <span class="n">islands_dist_sqr</span><span class="p">))</span>
<span class="c1"># convert to correlation matrix</span>
<span class="n">Σ_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span><span class="o">**-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ρ</span> <span class="o">=</span> <span class="n">Σ_post</span> <span class="o">@</span>  <span class="n">Σ</span> <span class="o">@</span> <span class="n">Σ_post</span>
<span class="n">ρ</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ρ</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">islands_dist</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
<span class="n">columns</span><span class="o">=</span><span class="n">islands_dist</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
<span class="n">ρ</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205246_9e.webp" /></p>
<p>从其他地方跳出的两个观察是，夏威夷非常孤独。这是有道理的，因为夏威夷离其他岛屿社会很远。此外，我们还可以看到 Malekula(Ml)、Tikopia(Ti) 和 Santa Cruz(Sc) 之间高度相关。这也是有道理的，因为这些社会非常接近，而且他们也有类似数量的工具。</p>
<p>现在我们将使用纬度和经度信息来绘制岛屿-社会的相对位置：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># scale point size to logpop</span>
<span class="n">logpop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">log_pop</span><span class="p">)</span>
<span class="n">logpop</span> <span class="o">/=</span> <span class="n">logpop</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="n">psize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logpop</span><span class="o">*</span><span class="mf">5.5</span><span class="p">)</span>
<span class="n">log_pop_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">lambda_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">trace_islands</span><span class="p">[</span><span class="s1">&#39;α&#39;</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span>
                     <span class="n">trace_islands</span><span class="p">[</span><span class="s1">&#39;β&#39;</span><span class="p">][:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">log_pop_seq</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">lon2</span><span class="p">,</span> <span class="n">islands</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">logpop</span><span class="p">,</span> <span class="n">islands</span><span class="o">.</span><span class="n">total_tools</span><span class="p">,</span> <span class="n">psize</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">itext</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">culture_labels</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">lon2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">islands</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">itext</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">logpop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mf">.1</span><span class="p">,</span> <span class="n">islands</span><span class="o">.</span><span class="n">total_tools</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">itext</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">log_pop_seq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lambda_post</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">log_pop_seq</span><span class="p">,</span> <span class="n">lambda_post</span><span class="p">,</span> <span class="n">fill_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span>
<span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;ls&#39;</span><span class="p">:</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">})</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">islands</span><span class="o">.</span><span class="n">lon2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">islands</span><span class="o">.</span><span class="n">lon2</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                   <span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">islands</span><span class="o">.</span><span class="n">lat</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="s1">&#39;C1-&#39;</span><span class="p">,</span>
                   <span class="n">alpha</span><span class="o">=</span><span class="n">ρ</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">((</span><span class="n">islands</span><span class="o">.</span><span class="n">logpop</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">islands</span><span class="o">.</span><span class="n">logpop</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span>
                   <span class="p">(</span><span class="n">islands</span><span class="o">.</span><span class="n">total_tools</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">islands</span><span class="o">.</span><span class="n">total_tools</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="s1">&#39;C1-&#39;</span><span class="p">,</span>
                   <span class="n">alpha</span><span class="o">=</span><span class="n">ρ</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;longitude&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;latitude&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;log-population&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;total tools&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mf">6.8</span><span class="p">,</span> <span class="mf">12.8</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">73</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205338_5f.webp" /></p>
<p>图 7.10 的左侧面板显示了我们之前在相对地理位置上下文中计算的社会之间的后验中值相关性的线条。有些线条是不可见的，因为我们已经使用相关性来设置线条的不透明度（使用 matplotlib 的 alpha 参数）。在右侧面板上，我们再次显示了后验中值相关性，但这一次是根据对数总体与工具总数绘制的。虚线表示工具的中位数和 HPD 94%的间隔作为对数填充的函数。在这两幅图中，圆点的大小与每个岛屿社会的人口成正比。</p>
<p>请注意 Malekula、Tikopia 和 Santa Cruz 之间的相关性如何描述这样一个事实，即它们拥有的工具数量相当少，接近或低于其人口的预期工具数量。类似的事情正发生在特罗布里兰岛和马努斯；它们地理位置相近，拥有的工具比预期的人口规模要少。汤加为其人口提供的工具比预期的要多得多，而且与斐济的相关性相对较高。在某种程度上，这个模型告诉我们，汤加对 Lua 斐济有积极的影响，增加了工具的总数，抵消了其近邻 Malekula、Tikopia 和 Santa Cruz 的影响。</p>
</div>
<div class="section" id="id9">
<h2>7.5 高斯过程分类<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>高斯过程不限于回归。我们也可以用它们来分类。正如我们在第 4 章“推广线性模型”中所看到的，我们通过使用带有 Logistic 逆链接函数的 Bernoulli 似然（然后应用边界判决规则来分离类），将线性模型转化为适合分类的模型。对于虹膜数据集，我们将尝试概括第 4 章“推广线性模型”中的 MODEL_0，这次使用的是 GP 而不是线性模型。</p>
<p>让我们再次邀请虹膜数据集上台：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">iris</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/iris.csv&#39;</span><span class="p">)</span>
<span class="n">iris</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="image-20210505205534881" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205541_6c.webp" /></p>
<p>我们将从最简单的分类问题开始：两类，刚毛和杂色，只有一个自变量，萼片长度。像往常一样，我们将使用数字 0 和 1 对分类变量 setosa 和 versicolor 进行编码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">iris</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s2">&quot;species == (&#39;setosa&#39;, &#39;versicolor&#39;)&quot;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Categorical</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;species&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">codes</span>
<span class="n">x_1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;sepal_length&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
<span class="n">X_1</span> <span class="o">=</span> <span class="n">x_1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
</pre></div>
</div>
<p>对于此模型，我们将使用 pm.gp.Latent 类，而不是使用 pm.gp.Marginal 类来实例化 GP 之前。虽然后者更一般，可以与任何可能性一起使用，但前者仅限于高斯可能性，并且通过利用 GP 先验与高斯可能性的组合在数学上的易操纵性而具有更高效率的优势：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_iris</span><span class="p">:</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ℓ</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Latent</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X_1</span><span class="p">)</span>
    <span class="c1"># logistic inverse link function and Bernoulli likelihood</span>
    <span class="n">y_</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Bernoulli</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">observed</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
    <span class="n">trace_iris</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="n">compute_convergence_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们已经找到了的值，我们可能想要从 GP 后验获取样本。与我们对 MARGING_GP_MODEL 所做的操作一样，我们还可以借助 gp.Conditional 函数计算一组新输入位置上计算的条件分布，如以下代码所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x_1</span><span class="o">.</span><span class="n">min</span><span class="p">()),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x_1</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> <span class="mi">200</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="k">with</span> <span class="n">model_iris</span><span class="p">:</span>
    <span class="n">f_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="s1">&#39;f_pred&#39;</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
    <span class="n">pred_samples</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample_posterior_predictive</span><span class="p">(</span>
        <span class="n">trace_iris</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">f_pred</span><span class="p">],</span> <span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>为了显示此模型的结果，我们将创建一个类似于图 4.4 的图。我们将使用以下便利函数直接从 f_pred 计算边界决策，而不是解析地获得边界决策：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_midpoint</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This should be a proper docstring :-)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array1</span><span class="p">)</span>
    <span class="n">idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array1</span> <span class="o">-</span> <span class="n">value</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">idx1</span> <span class="o">=</span> <span class="n">idx0</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">array1</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">value</span> <span class="k">else</span> <span class="n">idx0</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">idx1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">array1</span><span class="p">):</span>
        <span class="n">idx1</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">array2</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array2</span><span class="p">[</span><span class="n">idx1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>以下代码与第 4 章（泛化线性模型）中用于生成图 4.4 的代码非常相似：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">logistic</span><span class="p">(</span><span class="n">pred_samples</span><span class="p">[</span><span class="s1">&#39;f_pred&#39;</span><span class="p">])</span>
<span class="n">fp_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fp_mean</span><span class="p">)</span>
<span class="c1"># plot the data (with some jitter) and the true latent function</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">),</span>
           <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C2&#39;</span><span class="p">)</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">find_midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">])</span>
<span class="n">db_mean</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">db_hpd</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">hpd</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">db_mean</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_betweenx</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">db_hpd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">db_hpd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;sepal_length&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;θ&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;B11197_07_11.png&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205739_e4.webp" /></p>
<p>如我们所见，图 7.11 与图 4.4 非常相似。F_pred 曲线看起来像是一条 S 型曲线，除了尾部在较低的 x_1 值时上升，在较高的 x_1 值下降。这是当没有数据（或数据很少）时预测函数向前移动的结果。如果我们只关心边界决策，这应该不是一个真正的问题，但如果我们想要为不同的萼片长度值建立属于 setosa 或 versicolor 的概率模型，那么我们应该改进我们的模型，并做一些事情来获得更好的尾部模型。实现这一目标的一种方法是给高斯过程增加更多的结构。获得更好的高斯过程模型的一般方法是组合协方差函数，以便更好地捕捉我们试图建模的函数的细节。</p>
<p>以下模型 (Model_Iris2) 与 model_iris 相同，不同之处在于协方差矩阵，我们将其建模为三个内核的组合：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cov</span> <span class="o">=</span> <span class="n">K_</span><span class="p">{</span><span class="n">ExpQuad</span><span class="p">}</span> <span class="o">+</span> <span class="n">K_</span><span class="p">{</span><span class="n">Linear</span><span class="p">}</span> <span class="o">+</span> <span class="n">K_</span><span class="p">{</span><span class="n">whitenoise</span><span class="p">}(</span><span class="mf">1E-5</span><span class="p">)</span>
</pre></div>
</div>
<p>通过添加线性内核，我们修复了尾部问题，如图 7.12 所示。白噪声核只是一个稳定协方差矩阵计算的计算技巧。对高斯过程的核进行了限制，以保证得到的协方差矩阵是正定的。然而，数字错误可能会导致违反此条件。这个问题的一个表现是，我们在计算拟合函数的后验预测样本时会得到 NAN。减轻此错误的一种方法是通过添加一点噪声来稳定计算。事实上，PyMC3 已经在幕后做到了这一点，但有时需要更多一点噪音，如以下代码所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_iris2</span><span class="p">:</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Gamma</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">x_1</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">τ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s1">&#39;τ&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="p">(</span><span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ℓ</span><span class="p">)</span> <span class="o">+</span>
           <span class="n">τ</span> <span class="o">*</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span>
           <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">WhiteNoise</span><span class="p">(</span><span class="mf">1E-5</span><span class="p">))</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Latent</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X_1</span><span class="p">)</span>
    <span class="c1"># logistic inverse link function and Bernoulli likelihood</span>
    <span class="n">y_</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Bernoulli</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">observed</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
    <span class="n">trace_iris2</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="n">compute_convergence_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>现在，我们为先前生成的 X_new 值生成 model_iris2 的后验预测样本：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">model_iris2</span><span class="p">:</span>
    <span class="n">f_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="s1">&#39;f_pred&#39;</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
    <span class="n">pred_samples</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample_posterior_predictive</span><span class="p">(</span><span class="n">trace_iris2</span><span class="p">,</span>
                                                  <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">f_pred</span><span class="p">],</span>
                                                  <span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">logistic</span><span class="p">(</span><span class="n">pred_samples</span><span class="p">[</span><span class="s1">&#39;f_pred&#39;</span><span class="p">])</span>
<span class="n">fp_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">),</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span>
           <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">ci</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">y</span><span class="p">])</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">find_midpoint</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">X_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fp</span><span class="p">])</span>
<span class="n">db_mean</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">db_hpd</span> <span class="o">=</span> <span class="n">az</span><span class="o">.</span><span class="n">hpd</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">db_mean</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_betweenx</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">db_hpd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">db_hpd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">fp_mean</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C2&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;sepal_length&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;θ&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505205912_68.webp" /></p>
<p>现在，图 7.12 看起来更类似于图 4.4，而不是图 7.11。此示例有两个主要目的：</p>
<ul class="simple">
<li><p>展示如何轻松组合内核以获得更具表现力的模型</p></li>
<li><p>展示了如何使用高斯过程恢复 Logistic 回归</p></li>
</ul>
<p>关于第二点，Logistic 回归确实是高斯过程的特例，因为简单的线性回归只是高斯过程的特例。事实上，许多已知的模型可以被视为全科医生的特例，或者至少它们以某种方式与全科医生联系在一起。你可以阅读凯文·墨菲 (Kevin Murphy) 的“机器学习：概率视角”中的第 15 章，了解详细信息。</p>
<p>在实践中，使用 GP 对我们只能用 Logistic 回归来解决的问题进行建模并没有太大的意义。相反，我们希望使用 GP 来建模更复杂的数据，而这些数据使用灵活性较低的模型无法很好地捕获。例如，假设我们想要将患病概率建模为年龄的函数。事实证明，非常年轻和非常年长的人比中年人有更高的风险。数据集 space_flu.csv 是受前面描述启发的假数据集。让我们加载它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df_sf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/space_flu.csv&#39;</span><span class="p">)</span>
<span class="n">age</span> <span class="o">=</span> <span class="n">df_sf</span><span class="o">.</span><span class="n">age</span><span class="o">.</span><span class="n">values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="n">space_flu</span> <span class="o">=</span> <span class="n">df_sf</span><span class="o">.</span><span class="n">space_flu</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">df_sf</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;space_flu&#39;</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s1">&#39;healthy&#39;</span><span class="p">,</span> <span class="s1">&#39;sick&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210018_ba.webp" /></p>
<p>以下模型与 model_iris 基本相同：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_space_flu</span><span class="p">:</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfCauchy</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ℓ</span><span class="p">)</span> <span class="o">+</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">WhiteNoise</span><span class="p">(</span><span class="mf">1E-5</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Latent</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">age</span><span class="p">)</span>
    <span class="n">y_</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Bernoulli</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">observed</span><span class="o">=</span><span class="n">space_flu</span><span class="p">)</span>
    <span class="n">trace_space_flu</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
        <span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">compute_convergence_checks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>现在，我们为 model_space_flu 生成后验预测样本，然后绘制结果：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">200</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="k">with</span> <span class="n">model_space_flu</span><span class="p">:</span>
    <span class="n">f_pred</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">conditional</span><span class="p">(</span><span class="s1">&#39;f_pred&#39;</span><span class="p">,</span> <span class="n">X_new</span><span class="p">)</span>
    <span class="n">pred_samples</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample_posterior_predictive</span><span class="p">(</span><span class="n">trace_space_flu</span><span class="p">,</span>
                                                  <span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="n">f_pred</span><span class="p">],</span>
                                                  <span class="n">samples</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">fp</span> <span class="o">=</span> <span class="n">logistic</span><span class="p">(</span><span class="n">pred_samples</span><span class="p">[</span><span class="s1">&#39;f_pred&#39;</span><span class="p">])</span>
<span class="n">fp_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">age</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">space_flu</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">),</span>
           <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">ci</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">space_flu</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fp_mean</span><span class="p">,</span> <span class="s1">&#39;C2&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">X_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">fp</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;C2&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s1">&#39;healthy&#39;</span><span class="p">,</span> <span class="s1">&#39;sick&#39;</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="image-20210505210106544" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210109_bb.webp" /></p>
<p>请注意，如图 7.14 所示，GP 能够很好地适应此数据集，即使数据要求函数比逻辑函数更复杂。对于简单的逻辑回归来说，很好地拟合这个数据是不可能的，除非我们引入一些特殊的修改来帮助它（请参见练习 6 以了解有关此类修改的讨论）。</p>
</div>
<div class="section" id="cox">
<h2>7.6 Cox 过程<a class="headerlink" href="#cox" title="Permalink to this headline">¶</a></h2>
<p>现在让我们返回到对计数数据建模的示例。我们将看到两个示例；一个具有时变速率，另一个具有 2D 空间变化速率。为了做到这一点，我们将使用泊松似然，并且将使用高斯过程对速率进行建模。因为泊松分布的速率被限制为正值，所以我们将使用指数作为逆链接函数，就像我们在第 4 章-推广线性模型中对零膨胀泊松回归所做的那样。</p>
<p>在文献中，可变速率也以强度的名称出现，因此，这种类型的问题被称为强度估计。此外，这种类型的模型通常被称为 Cox 模型。考克斯模型是泊松过程的一种，其速率本身就是一个随机过程。正如高斯过程是随机变量的集合，其中这些随机变量的每个有限集合都具有多元正态分布一样，泊松过程是随机变量的集合，其中这些随机变量的每个有限集合都具有泊松分布。我们可以把泊松过程看作是在给定空间中的点的集合上的分布。当泊松过程的速率本身是随机过程时，例如，高斯过程，那么我们就有所谓的 Cox 过程。</p>
<div class="section" id="id10">
<h3>7.6.1 煤矿灾害<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>第一个例子被称为煤矿灾难例子。这个例子包括英国从 1851 年到 1962 年的煤矿灾难记录。灾难的数量被认为是在此期间受到安全法规变化的影响。我们希望将灾害率建模为时间的函数。我们的数据集只有一列，每个条目都对应于灾难发生的时间。</p>
<p>让我们加载数据并查看它的一些值：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coal_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/coal.csv&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">coal_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210251_00.webp" /></p>
<p>我们将用来拟合 COREE_DF 数据框中的数据的模型是：
$$
\begin{aligned} f(x) &amp; \sim \mathcal{G P}\left(\mu_{x}, K\left(x, x^{\prime}\right)\right) \
y &amp; \sim \operatorname{Poisson}(f(x)) \end{aligned}
$$
如你所见，这是一个泊松回归问题。你可能会想，在这一点上，如果我们只有一个列，只有灾难发生的日期，我们将如何执行回归。答案是将数据离散化，就像我们正在构建直方图一样。我们将使用存储箱的中心作为变量，每个存储箱的计数作为变量：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># discretize data</span>
<span class="n">years</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coal_df</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">values</span> <span class="o">-</span> <span class="n">coal_df</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="n">bins</span> <span class="o">=</span> <span class="n">years</span> <span class="o">//</span> <span class="mi">4</span>
<span class="n">hist</span><span class="p">,</span> <span class="n">x_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">coal_df</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
<span class="c1"># compute the location of the centers of the discretized data</span>
<span class="n">x_centers</span> <span class="o">=</span> <span class="n">x_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1"># arrange xdata into proper shape for GP</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="n">x_centers</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
<span class="c1"># express data as the rate number of disaster per year</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="n">hist</span> <span class="o">/</span> <span class="mi">4</span>
</pre></div>
</div>
<p>现在我们用 PyMC3 定义并求解该模型：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_coal</span><span class="p">:</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span> <span class="n">x_data</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>
    <span class="n">cov</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ℓ</span><span class="p">)</span> <span class="o">+</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">WhiteNoise</span><span class="p">(</span><span class="mf">1E-5</span><span class="p">)</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">Latent</span><span class="p">(</span><span class="n">cov_func</span><span class="o">=</span><span class="n">cov</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">x_data</span><span class="p">)</span>
    <span class="n">y_pred</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="s1">&#39;y_pred&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">observed</span><span class="o">=</span><span class="n">y_data</span><span class="p">)</span>
    <span class="n">trace_coal</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">chains</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>现在我们绘制结果图：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">f_trace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">trace_coal</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">])</span>
<span class="n">rate_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">f_trace</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_centers</span><span class="p">,</span> <span class="n">rate_median</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">x_centers</span><span class="p">,</span> <span class="n">f_trace</span><span class="p">)</span>
<span class="n">az</span><span class="o">.</span><span class="n">plot_hpd</span><span class="p">(</span><span class="n">x_centers</span><span class="p">,</span> <span class="n">f_trace</span><span class="p">,</span> <span class="n">credible_interval</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coal_df</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">coal_df</span><span class="p">)</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="s1">&#39;k|&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;years&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;rate&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210433_70.webp" /></p>
<p>图 7.15 用白线显示了灾害率的中位数与时间的关系。这些条带表示 50%HPD 间隔（较深）和 94%HPD 间隔（较浅）。在底部，我们用黑色记号笔标出了每一场灾难（这有时也被称为地毯图）。正如我们所看到的，事故率随着时间的推移而下降，除了最初的短暂上升。PyMC3 文档包括煤矿灾难，但从不同的角度建模。我强烈建议您检查该示例，因为它本身非常有用，而且将其与我们刚刚使用 model_Coal 模型实现的方法进行比较也很有用。</p>
<p>请注意，即使我们将数据入库，我们也会得到一条平滑的曲线。从这个意义上说，我们可以将 MODEL_COIL（通常是这种类型的模型）看作是构建一个直方图，然后对其进行平滑。</p>
</div>
<div class="section" id="id11">
<h3>7.6.2 红杉数据集<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>现在，我们将把注意力集中在使用红木数据对二维空间问题应用我们刚刚做过的相同类型的模型上。这个数据集（使用 GPL 许可证分发）来自 GPStuff 包，这是一个用于 Matlab、Octave 和 R 的高斯进程包。该数据集由给定区域上红杉树的位置组成。推论的动机是要找出这一地区的树木比率是如何分布的。</p>
<p>像往常一样，我们加载数据并绘制它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rw_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/redwood.csv&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rw_df</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rw_df</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;C0.&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x1 coordinate&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;x2 coordinate&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210601_88.webp" /></p>
<p>与煤矿灾难示例一样，我们需要对数据进行离散化：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># discretize spatial data</span>
<span class="n">bins</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">hist</span><span class="p">,</span> <span class="n">x1_edges</span><span class="p">,</span> <span class="n">x2_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span>
    <span class="n">rw_df</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rw_df</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
<span class="c1"># compute the location of the centers of the discretized data</span>
<span class="n">x1_centers</span> <span class="o">=</span> <span class="n">x1_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x1_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="n">x2_centers</span> <span class="o">=</span> <span class="n">x2_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x2_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
<span class="c1"># arrange xdata into proper shape for GP</span>
<span class="n">x_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1_centers</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x2_centers</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]]</span>
<span class="c1"># arrange ydata into proper shape for GP</span>
<span class="n">y_data</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
</pre></div>
</div>
<p>请注意，我们将 x1 和 x2 数据视为分开的数据，而不是网格网格。这允许我们为每个坐标构建协方差矩阵，从而有效地减小了计算 GP 所需的矩阵的大小。在使用 LatentKron 类定义 GP 时，我们只需小心。重要的是要注意，这不是一个数字技巧，而是这类矩阵结构的数学属性，因此我们不会在我们的模型中引入任何近似或误差。我们只是用一种更快的计算方式来表达它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">pm</span><span class="o">.</span><span class="n">Model</span><span class="p">()</span> <span class="k">as</span> <span class="n">model_rw</span><span class="p">:</span>
    <span class="n">ℓ</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">HalfNormal</span><span class="p">(</span><span class="s1">&#39;ℓ&#39;</span><span class="p">,</span>  <span class="n">rw_df</span><span class="o">.</span><span class="n">std</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">cov_func1</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ℓ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">cov_func2</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">cov</span><span class="o">.</span><span class="n">ExpQuad</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ℓ</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">gp</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">gp</span><span class="o">.</span><span class="n">LatentKron</span><span class="p">(</span><span class="n">cov_funcs</span><span class="o">=</span><span class="p">[</span><span class="n">cov_func1</span><span class="p">,</span> <span class="n">cov_func2</span><span class="p">])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gp</span><span class="o">.</span><span class="n">prior</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">Xs</span><span class="o">=</span><span class="n">x_data</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">Poisson</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">pm</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">observed</span><span class="o">=</span><span class="n">y_data</span><span class="p">)</span>
    <span class="n">trace_rw</span> <span class="o">=</span> <span class="n">pm</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>最后，我们绘制结果图：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">trace_rw</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">bins</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">ims</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ticks_loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ticks_lab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">ticks_loc</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks_loc</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">ticks_lab</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">ticks_lab</span><span class="p">)</span>
<span class="n">cbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">ims</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="mf">0.046</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.04</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210705_b5.webp" /></p>
<p>在图 7.17 中，较浅的颜色意味着比较深的颜色有更高的树木比率。我们可以想象，我们对寻找高增长率地区很感兴趣，因为我们可能对森林是如何从火灾中恢复的感兴趣，或者我们对土壤的性质感兴趣，我们把树木作为代理。</p>
</div>
</div>
<div class="section" id="id12">
<h2>7.7 总结<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>高斯过程是多元高斯分布到无限多维的推广，由均值函数和协方差函数完全指定。因为我们可以在概念上把函数看作无限长的向量，所以我们可以使用高斯过程作为函数的先验。在实践中，我们处理的不是无限大的对象，而是维数与数据点一样多的多变量高斯分布。为了定义相应的协方差函数，我们使用了适当的参数化核；通过学习这些超参数，我们最终了解了任意复杂函数。</p>
<p>这一章中，我们简要介绍了高斯过程，还有许多与之相关的主题 需要学习（比如构建一个半参数化模型，将线性模型作为均值函 数），或者是将两个或者多个核函数组合在一起来描述未知函数，或 者是如何将高斯过程用于分类任务，或者是如何将高斯过程与统计学 或者机器学习中的其他模型联系起来。不管怎么说，我希望本章对高 斯过程的介绍以及本书中一些其他主题的介绍能够激励你阅读、使用 和进一步学习贝叶斯统计。</p>
</div>
<div class="section" id="id13">
<h2>7.8 练习<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210819_20.webp" /></p>
<p><img alt="" src="https://gitee.com/XiShanSnow/imagebed/raw/master/images/articles/spatialPresent_20210505210830_d3.webp" /></p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="chapter06-MixtureModels.html" title="previous page">第6章 混合模型</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Guoliang PU<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>